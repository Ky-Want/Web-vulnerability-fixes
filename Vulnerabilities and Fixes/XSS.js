/* Vulnerability: XSS (Cross-site scripting)
URL: 

Description: XSS, or Cross-site scripting, occurs when either data enters a web application through an entrusted source, most frequently a web request, or when the data is included in dynamic content that is sent to a web user without being validated for malicious content. The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash, or any other type of code that the browser may execute. The variety of attacks based on XSS are almost limitless, but they commonly include transmitting private data, like cookies or other session information, to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user’s machine under the guise of the vulnerable site.

It’s been proven that to effectively prevent XSS vulnerabilities it’s necessary to involve a number of the subsequent measures:
1) FILTER INPUT UPON ARRIVAL: Ideally, you ought to filter input on arrival, meaning that the purpose where user input is received you ought to filter as strictly as possible supported what’s expected or valid input.
2) ENCODE YOUR DATA ON OUTPUT: You can encode the output to stop it from being interpreted as active content, but depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding.
3) USE ONLY APPROPRIATE RESPONSE HEADERS: To prevent XSS in HTTP responses not intended to contain any HTML or JavaScript, you should use Content-Type and X-Content-Type-Options headers and make sure browsers decode the responses within the way you intend them to.
4) HAVE A CONTENT SECURITY POLICY IN PLACE: As a final line of defense, you can use Content Security Policy to scale back the severity of any XSS vulnerabilities that also occur.



Code Fixes:
There are multiple ways by which a web application can protect itself from Cross-Site Scripting issues. Some of them include,
Blacklist filtering.
Whitelist filtering.
Contextual Encoding.
Input Validation.
Content Security Policy.


Blacklist filtering:
It is easy to implement a filtering technique that protects the website from XSS issues only partially. It works based on a known list of finite XSS vectors. For example, most XSS vectors use event listener attributes such as onerror, onmouseover, onkeypress etc., Using this fact, users given HTML attributes can be parsed and these event listeners attributes. This will mitigate a finite set of XSS vectors such as <img src=x onerror=alert()>.
For vectors like <a href=”javascript:alert()”>XSS</a>, one may remove javascript:, data:, vbscript: schemes from user given HTML.

<a href="javascript:alert()">XSS</a>   <img src=x onerror=alert()>
---> BLACKLIST FILTER: remove onerror, remove javascript, remove onmouseover --->
<a href="javascript:alert()">XSS</a>   <img src=x>

Advantages: 
  These filters are easy to implement in a web application.
  Almost zero risk of false positives of safe user content being filtered by these filter
Disadvantages:
  But this filtering can be easily bypassed as XSS vectors are not finite and cannot be maintained so. 
  Here is the list of some valid bypasses of this filter. This filtering doesn’t protect the website completely.
  <a href=”jAvAscRipt:alert()”>XSS</a>
  <a href=”jAvAs    cRipt:alert()”>XSS</a>
  <a href=”jAvAscRipt:prompt()”>XSS</a>



Whitelist filtering:
Whitelist filtering is the opposite of blacklist based filtering. Instead of listing out unsafe attributes and sanitizing user HTML with this list, whitelist filtering lists out a set of set HTML tags and attributes. Entities that are known to be sure safe are maintained and everything else will be filtered out.
This reduces XSS possibilities to the maximum extent and opens up XSS only when there is a loophole in the filter itself that treats some unsafe entities as safe. This filtering can be done both in the Client and server-side. Whitelist filtering is the most commonly used filter in modern web applications.

<a href="javascript:alert()">XSS</a>   <img src=x onerror=alert()>
---> WHITELIST FILTER: allow https:// in href, allow <pre>, <a>, <img> --->
<a>XSS</a>   <img src=x>

Advantages:
  Reduces XSS possibilities to a very good extent.
  Some whitelist filters like the Antisamy filter rewrite User content with Safe rules. 
  These causes rewriting of HTML content with strict standards of HTML language.
Disadvantages:
  More often this works by accepting unsafe or unsanitized HTML, parses them and constructs a safe HTML, and responds back to the user.
  This is performance intensive. Usage of these filters heavily may have a hidden performance impact on your modern web application.



Contextual encoding:
The other common mitigation technique is to consider all user given data as textual data and not HTML content, even if it is an HTML content. This can be done performing HTML entity encoding on user data.  Encoding <h1>test</h1> may get converted to <pre>&lt;test&gt; test &lt;/&gt;</pre> The browser will then parse this correctly and render <h1>test</h1> as text instead of rendering it as h1 HTML tag.

<img src=x onerror alert()>
---> CONTEXTUAL ENCODING: < ___>&It; > ___>gt; " ___>%22; --->
&It; img src=x onerror=alert() &gt;

Advantages:
  If done correctly, contextual encoding eliminates XSS risk completely.
Disadvantages:
  It treats all user data as unsafe.
  Thus, irrespective of the user data being safe or unsafe, all HTML content will be encoded and will be rendered as plain text.



Input validation:
In the Input validation technique, a regular expression is applied for every request parameter data i.e., user-generated content. Only if the content passes through a safe regular expression, it is then allowed. Otherwise, the request will be failed on the server-side with 400 response code.

1) https://google.com
2) javascript:alert()
---> REGEX MATCH: ^(https/http/ftp).* --->
1) https://google.com

Advantages
  Input validation not only reduces XSS but protects almost all vulnerabilities that may arise due to trusting user content.
Disadvantages
  It might be possible to mitigate an XSS in the phone number field by having a numeric regular expression validation but for a name field, it might not be possible as names can be in multiple languages and can have non-ASCII characters in Greek or Latin alphabets.
  Regular expression testing is performance intensive. All parameters in all requests to a server must be matched against a regular expression.



Content security policy:
The modern browser allows using of CSP or Content Security Policy Headers. With these headers, one can specify a list of domains only from which JavaScript content can be loaded. If the user tries to add a vulnerable JavaScript, CSP headers will block the request.

<img src=x onerror=alert()>
---> CSP HEADER: script_src=https://trusted.com --->
CSP blocked due to untrusted inline javascript

Advantages
  CSP is the most advanced form of XSS protection mechanism. It eliminates untrusted sources to enter data to websites in any form.
Disadvantages
  To have CSP headers defined, websites must not use inline JavaScript code. JS should be externalized and referred to in script tags. These set of domains that loads static content must be whitelisted in CSP headers.
*/